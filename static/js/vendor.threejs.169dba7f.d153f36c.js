"use strict";(self.webpackChunkvoltaris_website=self.webpackChunkvoltaris_website||[]).push([[910],{1119:(e,t,n)=>{n.d(t,{OH:()=>I});var r=n(8168),o=n(9950),i=n(2880),s=n(7226),a=n(8290),l=n(3323),c=n(793),u=n(6630);const d={apartment:"lebombo_1k.hdr",city:"potsdamer_platz_1k.hdr",dawn:"kiara_1_dawn_1k.hdr",forest:"forest_slope_1k.hdr",lobby:"st_fagans_interior_1k.hdr",night:"dikhololo_night_1k.hdr",park:"rooitou_park_1k.hdr",studio:"studio_small_03_1k.hdr",sunset:"venice_sunset_1k.hdr",warehouse:"empty_warehouse_01_1k.hdr"},f=3e3,p=3001,h="https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",m=e=>Array.isArray(e),g=["/px.png","/nx.png","/py.png","/ny.png","/pz.png","/nz.png"];function y(){let{files:e=g,path:t="",preset:n,encoding:r,extensions:a}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},l=null,c=!1;n&&(w(n),e=d[n],t=h),c=m(e);const{extension:u,isCubemap:y}=b(e);if(l=P(u),!l)throw new Error("useEnvironment: Unrecognized file extension: "+e);const v=(0,i.D)((e=>e.gl));(0,o.useLayoutEffect)((()=>{"webp"!==u&&"jpg"!==u&&"jpeg"!==u||v.domElement.addEventListener("webglcontextlost",(function(){i.H.clear(l,c?[e]:e)}),{once:!0})}),[e,v.domElement]);const x=(0,i.H)(l,c?[e]:e,(e=>{"webp"!==u&&"jpg"!==u&&"jpeg"!==u||e.setRenderer(v),null==e.setPath||e.setPath(t),a&&a(e)}));let B=c?x[0]:x;var A;"jpg"!==u&&"jpeg"!==u&&"webp"!==u||(B=null==(A=B.renderTarget)?void 0:A.texture);return B.mapping=y?s.hy7:s.wfO,"colorSpace"in B?B.colorSpace=(null!==r&&void 0!==r?r:y)?"srgb":"srgb-linear":B.encoding=(null!==r&&void 0!==r?r:y)?p:f,B}const v={files:g,path:"",preset:void 0,extensions:void 0};y.preload=e=>{const t={...v,...e};let{files:n,path:r=""}=t;const{preset:o,extensions:s}=t;o&&(w(o),n=d[o],r=h);const{extension:a}=b(n);if("webp"===a||"jpg"===a||"jpeg"===a)throw new Error("useEnvironment: Preloading gainmaps is not supported");const l=P(a);if(!l)throw new Error("useEnvironment: Unrecognized file extension: "+n);i.H.preload(l,m(n)?[n]:n,(e=>{null==e.setPath||e.setPath(r),s&&s(e)}))};const x={files:g,preset:void 0};function w(e){if(!(e in d))throw new Error("Preset must be one of: "+Object.keys(d).join(", "))}function b(e){var t;const n=m(e)&&6===e.length,r=m(e)&&3===e.length&&e.some((e=>e.endsWith("json"))),o=m(e)?e[0]:e;return{extension:n?"cube":r?"webp":o.startsWith("data:application/exr")?"exr":o.startsWith("data:application/hdr")?"hdr":o.startsWith("data:image/jpeg")?"jpg":null==(t=o.split(".").pop())||null==(t=t.split("?"))||null==(t=t.shift())?void 0:t.toLowerCase(),isCubemap:n,isGainmap:r}}function P(e){return"cube"===e?s.ScU:"hdr"===e?l.Y:"exr"===e?c.H:"jpg"===e||"jpeg"===e?u.pb:"webp"===e?u.j:null}y.clear=e=>{const t={...x,...e};let{files:n}=t;const{preset:r}=t;r&&(w(r),n=d[r]);const{extension:o}=b(n),s=P(o);if(!s)throw new Error("useEnvironment: Unrecognized file extension: "+n);i.H.clear(s,m(n)?[n]:n)};const B=e=>{return(t=e).current&&t.current.isScene?e.current:e;var t};function A(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};var s,a,l,c;o={backgroundBlurriness:0,backgroundIntensity:1,backgroundRotation:[0,0,0],environmentIntensity:1,environmentRotation:[0,0,0],...o};const u=B(t||n),d=u.background,f=u.environment,p={backgroundBlurriness:u.backgroundBlurriness,backgroundIntensity:u.backgroundIntensity,backgroundRotation:null!==(s=null==(a=u.backgroundRotation)||null==a.clone?void 0:a.clone())&&void 0!==s?s:[0,0,0],environmentIntensity:u.environmentIntensity,environmentRotation:null!==(l=null==(c=u.environmentRotation)||null==c.clone?void 0:c.clone())&&void 0!==l?l:[0,0,0]};return"only"!==e&&(u.environment=r),e&&(u.background=r),(0,i.k)(u,o),()=>{"only"!==e&&(u.environment=f),e&&(u.background=d),(0,i.k)(u,p)}}function T(e){let{scene:t,background:n=!1,map:r,...s}=e;const a=(0,i.D)((e=>e.scene));return o.useLayoutEffect((()=>{if(r)return A(n,t,a,r,s)})),null}function M(e){let{background:t=!1,scene:n,blur:r,backgroundBlurriness:s,backgroundIntensity:a,backgroundRotation:l,environmentIntensity:c,environmentRotation:u,...d}=e;const f=y(d),p=(0,i.D)((e=>e.scene));return o.useLayoutEffect((()=>A(t,n,p,f,{backgroundBlurriness:null!==r&&void 0!==r?r:s,backgroundIntensity:a,backgroundRotation:l,environmentIntensity:c,environmentRotation:u}))),o.useEffect((()=>()=>{f.dispose()}),[f]),null}function E(e){let{children:t,near:n=.1,far:r=1e3,resolution:a=256,frames:l=1,map:c,background:u=!1,blur:d,backgroundBlurriness:f,backgroundIntensity:p,backgroundRotation:h,environmentIntensity:m,environmentRotation:g,scene:y,files:v,path:x,preset:w,extensions:b}=e;const P=(0,i.D)((e=>e.gl)),B=(0,i.D)((e=>e.scene)),E=o.useRef(null),[S]=o.useState((()=>new s.Z58)),I=o.useMemo((()=>{const e=new s.o6l(a);return e.texture.type=s.ix0,e}),[a]);o.useEffect((()=>()=>{I.dispose()}),[I]),o.useLayoutEffect((()=>{if(1===l){const e=P.autoClear;P.autoClear=!0,E.current.update(P,S),P.autoClear=e}return A(u,y,B,I.texture,{backgroundBlurriness:null!==d&&void 0!==d?d:f,backgroundIntensity:p,backgroundRotation:h,environmentIntensity:m,environmentRotation:g})}),[t,S,I.texture,y,B,u,l,P]);let k=1;return(0,i.F)((()=>{if(l===1/0||k<l){const e=P.autoClear;P.autoClear=!0,E.current.update(P,S),P.autoClear=e,k++}})),o.createElement(o.Fragment,null,(0,i.h)(o.createElement(o.Fragment,null,t,o.createElement("cubeCamera",{ref:E,args:[n,r,I]}),v||w?o.createElement(M,{background:!0,files:v,preset:w,path:x,extensions:b}):c?o.createElement(T,{background:!0,map:c,extensions:b}):null),S))}function S(e){var t,n,s,l;const c=y(e),u=e.map||c;o.useMemo((()=>(0,i.e)({GroundProjectedEnvImpl:a.L})),[]),o.useEffect((()=>()=>{c.dispose()}),[c]);const d=o.useMemo((()=>[u]),[u]),f=null==(t=e.ground)?void 0:t.height,p=null==(n=e.ground)?void 0:n.radius,h=null!==(s=null==(l=e.ground)?void 0:l.scale)&&void 0!==s?s:1e3;return o.createElement(o.Fragment,null,o.createElement(T,(0,r.A)({},e,{map:u})),o.createElement("groundProjectedEnvImpl",{args:d,scale:h,height:f,radius:p}))}function I(e){return e.ground?o.createElement(S,e):e.map?o.createElement(T,e):e.children?o.createElement(E,e):o.createElement(M,e)}},1162:(e,t,n)=>{n.d(t,{n:()=>s});var r=n(9950),o=n(2880),i=n(7226);const s=r.forwardRef(((e,t)=>{let{children:n,enabled:s=!0,speed:a=1,rotationIntensity:l=1,floatIntensity:c=1,floatingRange:u=[-.1,.1],autoInvalidate:d=!1,...f}=e;const p=r.useRef(null);r.useImperativeHandle(t,(()=>p.current),[]);const h=r.useRef(1e4*Math.random());return(0,o.F)((e=>{var t,n;if(!s||0===a)return;d&&e.invalidate();const r=h.current+e.clock.elapsedTime;p.current.rotation.x=Math.cos(r/4*a)/8*l,p.current.rotation.y=Math.sin(r/4*a)/8*l,p.current.rotation.z=Math.sin(r/4*a)/20*l;let o=Math.sin(r/4*a)/10;o=i.cj9.mapLinear(o,-.1,.1,null!==(t=null==u?void 0:u[0])&&void 0!==t?t:-.1,null!==(n=null==u?void 0:u[1])&&void 0!==n?n:.1),p.current.position.y=o*c,p.current.updateMatrix()})),r.createElement("group",f,r.createElement("group",{ref:p,matrixAutoUpdate:!1},n))}))},1185:(e,t,n)=>{n.d(t,{n:()=>u});var r=n(8168),o=n(9950),i=n(7226),s=n(2880);const a=(()=>parseInt(i.sPf.replace(/\D+/g,"")))();class l extends i.BKk{constructor(){super({uniforms:{depth:{value:null},opacity:{value:1},attenuation:{value:2.5},anglePower:{value:12},spotPosition:{value:new i.Pq0(0,0,0)},lightColor:{value:new i.Q1f("white")},cameraNear:{value:0},cameraFar:{value:1},resolution:{value:new i.I9Y(0,0)}},transparent:!0,depthWrite:!1,vertexShader:"\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n        uniform vec3 spotPosition;\n        uniform float attenuation;\n\n        #include <common>\n        #include <logdepthbuf_pars_vertex>\n\n        void main() {\n          // compute intensity\n          vNormal = normalize(normalMatrix * normal);\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\n          vec4 viewPosition = viewMatrix * worldPosition;\n          vViewZ = viewPosition.z;\n\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\n\n          gl_Position = projectionMatrix * viewPosition;\n\n          #include <logdepthbuf_vertex>\n        }\n      ",fragmentShader:`\n        varying vec3 vNormal;\n        varying float vViewZ;\n        varying float vIntensity;\n\n        uniform vec3 lightColor;\n        uniform float anglePower;\n        uniform sampler2D depth;\n        uniform vec2 resolution;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float opacity;\n\n        #include <packing>\n        #include <logdepthbuf_pars_fragment>\n\n        float readDepth(sampler2D depthSampler, vec2 uv) {\n          float fragCoordZ = texture(depthSampler, uv).r;\n\n          // https://github.com/mrdoob/three.js/issues/23072\n          #ifdef USE_LOGDEPTHBUF\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\n          #else\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n          #endif\n\n          return viewZ;\n        }\n\n        void main() {\n          #include <logdepthbuf_fragment>\n\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\n          float intensity = vIntensity * angleIntensity;\n\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\n          if (isSoft) {\n            vec2 uv = gl_FragCoord.xy / resolution;\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\n          }\n\n          gl_FragColor = vec4(lightColor, intensity * opacity);\n\n          #include <tonemapping_fragment>\n          #include <${a>=154?"colorspace_fragment":"encodings_fragment"}>\n        }\n      `})}}function c(e){let{opacity:t=1,radiusTop:n,radiusBottom:r,depthBuffer:a,color:c="white",distance:u=5,angle:d=.15,attenuation:f=5,anglePower:p=5}=e;const h=o.useRef(null),m=(0,s.D)((e=>e.size)),g=(0,s.D)((e=>e.camera)),y=(0,s.D)((e=>e.viewport.dpr)),[v]=o.useState((()=>new l)),[x]=o.useState((()=>new i.Pq0));n=void 0===n?.1:n,r=void 0===r?7*d:r,(0,s.F)((()=>{v.uniforms.spotPosition.value.copy(h.current.getWorldPosition(x)),h.current.lookAt(h.current.parent.target.getWorldPosition(x))}));const w=o.useMemo((()=>{const e=new i.Ho_(n,r,u,128,64,!0);return e.applyMatrix4((new i.kn4).makeTranslation(0,-u/2,0)),e.applyMatrix4((new i.kn4).makeRotationX(-Math.PI/2)),e}),[u,n,r]);return o.createElement(o.Fragment,null,o.createElement("mesh",{ref:h,geometry:w,raycast:()=>null},o.createElement("primitive",{object:v,attach:"material","uniforms-opacity-value":t,"uniforms-lightColor-value":c,"uniforms-attenuation-value":f,"uniforms-anglePower-value":p,"uniforms-depth-value":a,"uniforms-cameraNear-value":g.near,"uniforms-cameraFar-value":g.far,"uniforms-resolution-value":a?[m.width*y,m.height*y]:[0,0]})))}const u=o.forwardRef(((e,t)=>{let{opacity:n=1,radiusTop:i,radiusBottom:s,depthBuffer:a,color:l="white",distance:u=5,angle:d=.15,attenuation:f=5,anglePower:p=5,volumetric:h=!0,debug:m=!1,children:g,...y}=e;const v=o.useRef(null);return o.useImperativeHandle(t,(()=>v.current),[]),o.createElement("group",null,m&&v.current&&o.createElement("spotLightHelper",{args:[v.current]}),o.createElement("spotLight",(0,r.A)({ref:v,angle:d,color:l,distance:u,castShadow:!0},y),h&&o.createElement(c,{debug:m,opacity:n,radiusTop:i,radiusBottom:s,depthBuffer:a,color:l,distance:u,angle:d,attenuation:f,anglePower:p})),g&&o.cloneElement(g,{spotlightRef:v,debug:m}))}))},1878:(e,t,n)=>{n.d(t,{N:()=>a});var r=n(8168),o=n(2880),i=n(9950),s=n(5455);const a=i.forwardRef(((e,t)=>{let{makeDefault:n,camera:a,regress:l,domElement:c,enableDamping:u=!0,keyEvents:d=!1,onChange:f,onStart:p,onEnd:h,...m}=e;const g=(0,o.D)((e=>e.invalidate)),y=(0,o.D)((e=>e.camera)),v=(0,o.D)((e=>e.gl)),x=(0,o.D)((e=>e.events)),w=(0,o.D)((e=>e.setEvents)),b=(0,o.D)((e=>e.set)),P=(0,o.D)((e=>e.get)),B=(0,o.D)((e=>e.performance)),A=a||y,T=c||x.connected||v.domElement,M=i.useMemo((()=>new s.N(A)),[A]);return(0,o.F)((()=>{M.enabled&&M.update()}),-1),i.useEffect((()=>(d&&M.connect(!0===d?T:d),M.connect(T),()=>{M.dispose()})),[d,T,l,M,g]),i.useEffect((()=>{const e=e=>{g(),l&&B.regress(),f&&f(e)},t=e=>{p&&p(e)},n=e=>{h&&h(e)};return M.addEventListener("change",e),M.addEventListener("start",t),M.addEventListener("end",n),()=>{M.removeEventListener("start",t),M.removeEventListener("end",n),M.removeEventListener("change",e)}}),[f,p,h,M,g,w]),i.useEffect((()=>{if(n){const e=P().controls;return b({controls:M}),()=>b({controls:e})}}),[n,M]),i.createElement("primitive",(0,r.A)({ref:t,object:M,enableDamping:u},m))}))},2115:(e,t,n)=>{n.d(t,{_:()=>c});var r=n(8168),o=n(9950),i=n(7226),s=n(2880),a=n(7176),l=n(2926);const c=o.forwardRef(((e,t)=>{let{scale:n=10,frames:c=1/0,opacity:u=1,width:d=1,height:f=1,blur:p=1,near:h=0,far:m=10,resolution:g=512,smooth:y=!0,color:v="#000000",depthWrite:x=!1,renderOrder:w,...b}=e;const P=o.useRef(null),B=(0,s.D)((e=>e.scene)),A=(0,s.D)((e=>e.gl)),T=o.useRef(null);d*=Array.isArray(n)?n[0]:n||1,f*=Array.isArray(n)?n[1]:n||1;const[M,E,S,I,k,_,F]=o.useMemo((()=>{const e=new i.nWS(g,g),t=new i.nWS(g,g);t.texture.generateMipmaps=e.texture.generateMipmaps=!1;const n=new i.bdM(d,f).rotateX(Math.PI/2),r=new i.eaF(n),o=new i.CSG;o.depthTest=o.depthWrite=!1,o.onBeforeCompile=e=>{e.uniforms={...e.uniforms,ucolor:{value:new i.Q1f(v)}},e.fragmentShader=e.fragmentShader.replace("void main() {","uniform vec3 ucolor;\n           void main() {\n          "),e.fragmentShader=e.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );","vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );")};const s=new i.BKk(a.F),c=new i.BKk(l.r);return c.depthTest=s.depthTest=!1,[e,n,o,r,s,c,t]}),[g,d,f,n,v]),q=e=>{I.visible=!0,I.material=k,k.uniforms.tDiffuse.value=M.texture,k.uniforms.h.value=1*e/256,A.setRenderTarget(F),A.render(I,T.current),I.material=_,_.uniforms.tDiffuse.value=F.texture,_.uniforms.v.value=1*e/256,A.setRenderTarget(M),A.render(I,T.current),I.visible=!1};let R,U,C=0;return(0,s.F)((()=>{T.current&&(c===1/0||C<c)&&(C++,R=B.background,U=B.overrideMaterial,P.current.visible=!1,B.background=null,B.overrideMaterial=S,A.setRenderTarget(M),A.render(B,T.current),q(p),y&&q(.4*p),A.setRenderTarget(null),P.current.visible=!0,B.overrideMaterial=U,B.background=R)})),o.useImperativeHandle(t,(()=>P.current),[]),o.createElement("group",(0,r.A)({"rotation-x":Math.PI/2},b,{ref:P}),o.createElement("mesh",{renderOrder:w,geometry:E,scale:[1,-1,1],rotation:[-Math.PI/2,0,0]},o.createElement("meshBasicMaterial",{transparent:!0,map:M.texture,opacity:u,depthWrite:x})),o.createElement("orthographicCamera",{ref:T,args:[-d/2,d/2,f/2,-f/2,h,m]}))}))},2182:(e,t,n)=>{n.d(t,{u:()=>l});var r=n(8168),o=n(9950),i=n(2880),s=n(7226);function a(e,t,n){const r=(0,i.D)((e=>e.size)),a=(0,i.D)((e=>e.viewport)),l="number"===typeof e?e:r.width*a.dpr,c="number"===typeof t?t:r.height*a.dpr,u=("number"===typeof e?n:e)||{},{samples:d=0,depth:f,...p}=u,h=o.useMemo((()=>{const e=new s.nWS(l,c,{minFilter:s.k6q,magFilter:s.k6q,type:s.ix0,...p});return f&&(e.depthTexture=new s.VCu(l,c,s.RQf)),e.samples=d,e}),[]);return o.useLayoutEffect((()=>{h.setSize(l,c),d&&(h.samples=d)}),[d,h,l,c]),o.useEffect((()=>()=>h.dispose()),[]),h}const l=o.forwardRef(((e,t)=>{let{envMap:n,resolution:s=256,frames:l=1/0,makeDefault:c,children:u,...d}=e;const f=(0,i.D)((e=>{let{set:t}=e;return t})),p=(0,i.D)((e=>{let{camera:t}=e;return t})),h=(0,i.D)((e=>{let{size:t}=e;return t})),m=o.useRef(null);o.useImperativeHandle(t,(()=>m.current),[]);const g=o.useRef(null),y=a(s);o.useLayoutEffect((()=>{d.manual||(m.current.aspect=h.width/h.height)}),[h,d]),o.useLayoutEffect((()=>{m.current.updateProjectionMatrix()}));let v=0,x=null;const w="function"===typeof u;return(0,i.F)((e=>{w&&(l===1/0||v<l)&&(g.current.visible=!1,e.gl.setRenderTarget(y),x=e.scene.background,n&&(e.scene.background=n),e.gl.render(e.scene,m.current),e.scene.background=x,e.gl.setRenderTarget(null),g.current.visible=!0,v++)})),o.useLayoutEffect((()=>{if(c){const e=p;return f((()=>({camera:m.current}))),()=>f((()=>({camera:e})))}}),[m,c,f]),o.createElement(o.Fragment,null,o.createElement("perspectiveCamera",(0,r.A)({ref:m},d),!w&&u),o.createElement("group",{ref:g},w&&u(y.texture)))}))},2342:(e,t,n)=>{n.d(t,{E:()=>v});var r=n(8168),o=n(9950),i=n(1352),s=n(7226),a=n(2880);const l=new s.Pq0,c=new s.Pq0,u=new s.Pq0,d=new s.I9Y;function f(e,t,n){const r=l.setFromMatrixPosition(e.matrixWorld);r.project(t);const o=n.width/2,i=n.height/2;return[r.x*o+o,-r.y*i+i]}const p=e=>Math.abs(e)<1e-10?0:e;function h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"",r="matrix3d(";for(let o=0;16!==o;o++)r+=p(t[o]*e.elements[o])+(15!==o?",":")");return n+r}const m=(g=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],e=>h(e,g));var g;const y=(e,t)=>{return h(e,[1/(n=t),1/n,1/n,1,-1/n,-1/n,-1/n,-1,1/n,1/n,1/n,1,1,1,1,1],"translate(-50%,-50%)");var n};const v=o.forwardRef(((e,t)=>{let{children:n,eps:h=.001,style:g,className:v,prepend:x,center:w,fullscreen:b,portal:P,distanceFactor:B,sprite:A=!1,transform:T=!1,occlude:M,onOcclude:E,castShadow:S,receiveShadow:I,material:k,geometry:_,zIndexRange:F=[16777271,0],calculatePosition:q=f,as:R="div",wrapperClass:U,pointerEvents:C="auto",...z}=e;const{gl:D,camera:N,scene:W,size:j,raycaster:L,events:Z,viewport:H}=(0,a.D)(),[V]=o.useState((()=>document.createElement(R))),Y=o.useRef(),O=o.useRef(null),$=o.useRef(0),X=o.useRef([0,0]),G=o.useRef(null),K=o.useRef(null),Q=(null==P?void 0:P.current)||Z.connected||D.domElement.parentNode,J=o.useRef(null),ee=o.useRef(!1),te=o.useMemo((()=>M&&"blending"!==M||Array.isArray(M)&&M.length&&function(e){return e&&"object"===typeof e&&"current"in e}(M[0])),[M]);o.useLayoutEffect((()=>{const e=D.domElement;M&&"blending"===M?(e.style.zIndex=`${Math.floor(F[0]/2)}`,e.style.position="absolute",e.style.pointerEvents="none"):(e.style.zIndex=null,e.style.position=null,e.style.pointerEvents=null)}),[M]),o.useLayoutEffect((()=>{if(O.current){const e=Y.current=i.createRoot(V);if(W.updateMatrixWorld(),T)V.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const e=q(O.current,N,j);V.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${e[0]}px,${e[1]}px,0);transform-origin:0 0;`}return Q&&(x?Q.prepend(V):Q.appendChild(V)),()=>{Q&&Q.removeChild(V),e.unmount()}}}),[Q,T]),o.useLayoutEffect((()=>{U&&(V.className=U)}),[U]);const ne=o.useMemo((()=>T?{position:"absolute",top:0,left:0,width:j.width,height:j.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:w?"translate3d(-50%,-50%,0)":"none",...b&&{top:-j.height/2,left:-j.width/2,width:j.width,height:j.height},...g}),[g,w,b,j,T]),re=o.useMemo((()=>({position:"absolute",pointerEvents:C})),[C]);o.useLayoutEffect((()=>{var e,r;(ee.current=!1,T)?null==(e=Y.current)||e.render(o.createElement("div",{ref:G,style:ne},o.createElement("div",{ref:K,style:re},o.createElement("div",{ref:t,className:v,style:g,children:n})))):null==(r=Y.current)||r.render(o.createElement("div",{ref:t,style:ne,className:v,children:n}))}));const oe=o.useRef(!0);(0,a.F)((e=>{if(O.current){N.updateMatrixWorld(),O.current.updateWorldMatrix(!0,!1);const e=T?X.current:q(O.current,N,j);if(T||Math.abs($.current-N.zoom)>h||Math.abs(X.current[0]-e[0])>h||Math.abs(X.current[1]-e[1])>h){const t=function(e,t){const n=l.setFromMatrixPosition(e.matrixWorld),r=c.setFromMatrixPosition(t.matrixWorld),o=n.sub(r),i=t.getWorldDirection(u);return o.angleTo(i)>Math.PI/2}(O.current,N);let n=!1;te&&(Array.isArray(M)?n=M.map((e=>e.current)):"blending"!==M&&(n=[W]));const r=oe.current;if(n){const e=function(e,t,n,r){const o=l.setFromMatrixPosition(e.matrixWorld),i=o.clone();i.project(t),d.set(i.x,i.y),n.setFromCamera(d,t);const s=n.intersectObjects(r,!0);if(s.length){const e=s[0].distance;return o.distanceTo(n.ray.origin)<e}return!0}(O.current,N,L,n);oe.current=e&&!t}else oe.current=!t;r!==oe.current&&(E?E(!oe.current):V.style.display=oe.current?"block":"none");const o=Math.floor(F[0]/2),i=M?te?[F[0],o]:[o-1,0]:F;if(V.style.zIndex=`${function(e,t,n){if(t instanceof s.ubm||t instanceof s.qUd){const r=l.setFromMatrixPosition(e.matrixWorld),o=c.setFromMatrixPosition(t.matrixWorld),i=r.distanceTo(o),s=(n[1]-n[0])/(t.far-t.near),a=n[1]-s*t.far;return Math.round(s*i+a)}}(O.current,N,i)}`,T){const[e,t]=[j.width/2,j.height/2],n=N.projectionMatrix.elements[5]*t,{isOrthographicCamera:r,top:o,left:i,bottom:s,right:a}=N,l=m(N.matrixWorldInverse),c=r?`scale(${n})translate(${p(-(a+i)/2)}px,${p((o+s)/2)}px)`:`translateZ(${n}px)`;let u=O.current.matrixWorld;A&&(u=N.matrixWorldInverse.clone().transpose().copyPosition(u).scale(O.current.scale),u.elements[3]=u.elements[7]=u.elements[11]=0,u.elements[15]=1),V.style.width=j.width+"px",V.style.height=j.height+"px",V.style.perspective=r?"":`${n}px`,G.current&&K.current&&(G.current.style.transform=`${c}${l}translate(${e}px,${t}px)`,K.current.style.transform=y(u,1/((B||10)/400)))}else{const t=void 0===B?1:function(e,t){if(t instanceof s.qUd)return t.zoom;if(t instanceof s.ubm){const n=l.setFromMatrixPosition(e.matrixWorld),r=c.setFromMatrixPosition(t.matrixWorld),o=t.fov*Math.PI/180,i=n.distanceTo(r);return 1/(2*Math.tan(o/2)*i)}return 1}(O.current,N)*B;V.style.transform=`translate3d(${e[0]}px,${e[1]}px,0) scale(${t})`}X.current=e,$.current=N.zoom}}if(!te&&J.current&&!ee.current)if(T){if(G.current){const e=G.current.children[0];if(null!=e&&e.clientWidth&&null!=e&&e.clientHeight){const{isOrthographicCamera:t}=N;if(t||_)z.scale&&(Array.isArray(z.scale)?z.scale instanceof s.Pq0?J.current.scale.copy(z.scale.clone().divideScalar(1)):J.current.scale.set(1/z.scale[0],1/z.scale[1],1/z.scale[2]):J.current.scale.setScalar(1/z.scale));else{const t=(B||10)/400,n=e.clientWidth*t,r=e.clientHeight*t;J.current.scale.set(n,r,1)}ee.current=!0}}}else{const t=V.children[0];if(null!=t&&t.clientWidth&&null!=t&&t.clientHeight){const e=1/H.factor,n=t.clientWidth*e,r=t.clientHeight*e;J.current.scale.set(n,r,1),ee.current=!0}J.current.lookAt(e.camera.position)}}));const ie=o.useMemo((()=>({vertexShader:T?void 0:'\n          /*\n            This shader is from the THREE\'s SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if "transfrom"\n            is false.\n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n\n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ',fragmentShader:"\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      "})),[T]);return o.createElement("group",(0,r.A)({},z,{ref:O}),M&&!te&&o.createElement("mesh",{castShadow:S,receiveShadow:I,ref:J},_||o.createElement("planeGeometry",null),k||o.createElement("shaderMaterial",{side:s.$EB,vertexShader:ie.vertexShader,fragmentShader:ie.fragmentShader})))}))},6739:(e,t,n)=>{n.d(t,{Y:()=>Zt});var r=n(9950);const o=2,i=1.25,s=65535,a=Math.pow(2,-24),l=Symbol("SKIP_GENERATION");var c=n(7226);function u(e,t,n){return null===e?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(n.ray.origin),e.object=t,e)}function d(e){return function(e){return e.index?e.index.count:e.attributes.position.count}(e)/3}function f(e,t){if(!e.index){const n=e.attributes.position.count,r=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ArrayBuffer;return e>65535?new Uint32Array(new t(4*e)):new Uint16Array(new t(2*e))}(n,t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);e.setIndex(new c.THS(r,1));for(let e=0;e<n;e++)r[e]=e}}function p(e,t){const n=d(e),r=t||e.drawRange,o=r.start/3,i=(r.start+r.count)/3,s=Math.max(0,o),a=Math.min(n,i)-s;return[{offset:Math.floor(s),count:Math.floor(a)}]}function h(e,t){if(!e.groups||!e.groups.length)return p(e,t);const n=[],r=new Set,o=t||e.drawRange,i=o.start/3,s=(o.start+o.count)/3;for(const l of e.groups){const e=l.start/3,t=(l.start+l.count)/3;r.add(Math.max(i,e)),r.add(Math.min(s,t))}const a=Array.from(r.values()).sort(((e,t)=>e-t));for(let l=0;l<a.length-1;l++){const e=a[l],t=a[l+1];n.push({offset:Math.floor(e),count:Math.floor(t-e)})}return n}function m(e,t,n,r,o){let i=1/0,s=1/0,a=1/0,l=-1/0,c=-1/0,u=-1/0,d=1/0,f=1/0,p=1/0,h=-1/0,m=-1/0,g=-1/0;for(let y=6*t,v=6*(t+n);y<v;y+=6){const t=e[y+0],n=e[y+1],r=t-n,o=t+n;r<i&&(i=r),o>l&&(l=o),t<d&&(d=t),t>h&&(h=t);const v=e[y+2],x=e[y+3],w=v-x,b=v+x;w<s&&(s=w),b>c&&(c=b),v<f&&(f=v),v>m&&(m=v);const P=e[y+4],B=e[y+5],A=P-B,T=P+B;A<a&&(a=A),T>u&&(u=T),P<p&&(p=P),P>g&&(g=P)}r[0]=i,r[1]=s,r[2]=a,r[3]=l,r[4]=c,r[5]=u,o[0]=d,o[1]=f,o[2]=p,o[3]=h,o[4]=m,o[5]=g}function g(e,t,n){return n.min.x=t[e],n.min.y=t[e+1],n.min.z=t[e+2],n.max.x=t[e+3],n.max.y=t[e+4],n.max.z=t[e+5],n}function y(e){let t=-1,n=-1/0;for(let r=0;r<3;r++){const o=e[r+3]-e[r];o>n&&(n=o,t=r)}return t}function v(e,t){t.set(e)}function x(e,t,n){let r,o;for(let i=0;i<3;i++){const s=i+3;r=e[i],o=t[i],n[i]=r<o?r:o,r=e[s],o=t[s],n[s]=r>o?r:o}}function w(e,t,n){for(let r=0;r<3;r++){const o=t[e+2*r],i=t[e+2*r+1],s=o-i,a=o+i;s<n[r]&&(n[r]=s),a>n[r+3]&&(n[r+3]=a)}}function b(e){const t=e[3]-e[0],n=e[4]-e[1],r=e[5]-e[2];return 2*(t*n+n*r+r*t)}const P=32,B=(e,t)=>e.candidate-t.candidate,A=new Array(P).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),T=new Float32Array(6);class M{constructor(){this.boundingData=new Float32Array(6)}}function E(e,t,n,r,o,i){let s=r,a=r+o-1;const l=i.pos,c=2*i.axis;for(;;){for(;s<=a&&n[6*s+c]<l;)s++;for(;s<=a&&n[6*a+c]>=l;)a--;if(!(s<a))return s;for(let e=0;e<3;e++){let n=t[3*s+e];t[3*s+e]=t[3*a+e],t[3*a+e]=n}for(let e=0;e<6;e++){let t=n[6*s+e];n[6*s+e]=n[6*a+e],n[6*a+e]=t}s++,a--}}function S(e,t,n,r,o,i){let s=r,a=r+o-1;const l=i.pos,c=2*i.axis;for(;;){for(;s<=a&&n[6*s+c]<l;)s++;for(;s<=a&&n[6*a+c]>=l;)a--;if(!(s<a))return s;{let t=e[s];e[s]=e[a],e[a]=t;for(let e=0;e<6;e++){let t=n[6*s+e];n[6*s+e]=n[6*a+e],n[6*a+e]=t}s++,a--}}}function I(e,t){return 65535===t[e+15]}function k(e,t){return t[e+6]}function _(e,t){return t[e+14]}function F(e){return e+8}function q(e,t){return t[e+6]}function R(e,t){return t[e+7]}let U,C,z,D;const N=Math.pow(2,32);function W(e){return"count"in e?1:1+W(e.left)+W(e.right)}function j(e,t,n){return U=new Float32Array(n),C=new Uint32Array(n),z=new Uint16Array(n),D=new Uint8Array(n),L(e,t)}function L(e,t){const n=e/4,r=e/2,o="count"in t,i=t.boundingData;for(let s=0;s<6;s++)U[n+s]=i[s];if(o){if(t.buffer){const r=t.buffer;D.set(new Uint8Array(r),e);for(let t=e,o=e+r.byteLength;t<o;t+=32){I(t/2,z)||(C[t/4+6]+=n)}return e+r.byteLength}{const o=t.offset,i=t.count;return C[n+6]=o,z[r+14]=i,z[r+15]=s,e+32}}{const r=t.left,o=t.right,i=t.splitAxis;let s;if(s=L(e+32,r),s/4>N)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return C[n+6]=s/4,s=L(s,o),C[n+7]=i,s}}function Z(e,t,n,r,s){const{maxDepth:a,verbose:l,maxLeafTris:c,strategy:u,onProgress:f,indirect:p}=s,h=e._indirectBuffer,g=e.geometry,I=g.index?g.index.array:null,k=p?S:E,_=d(g),F=new Float32Array(6);let q=!1;const R=new M;return m(t,n,r,R.boundingData,F),function e(n,r,s){let d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;!q&&f>=a&&(q=!0,l&&(console.warn(`MeshBVH: Max depth of ${a} reached when generating BVH. Consider increasing maxDepth.`),console.warn(g)));if(s<=c||f>=a)return U(r+s),n.offset=r,n.count=s,n;const p=function(e,t,n,r,s,a){let l=-1,c=0;if(0===a)l=y(t),-1!==l&&(c=(t[l]+t[l+3])/2);else if(1===a)l=y(e),-1!==l&&(c=function(e,t,n,r){let o=0;for(let i=t,s=t+n;i<s;i++)o+=e[6*i+2*r];return o/n}(n,r,s,l));else if(a===o){const o=b(e);let a=i*s;const u=6*r,d=6*(r+s);for(let e=0;e<3;e++){const r=t[e],f=(t[e+3]-r)/P;if(s<8){const t=[...A];t.length=s;let r=0;for(let o=u;o<d;o+=6,r++){const i=t[r];i.candidate=n[o+2*e],i.count=0;const{bounds:s,leftCacheBounds:a,rightCacheBounds:l}=i;for(let e=0;e<3;e++)l[e]=1/0,l[e+3]=-1/0,a[e]=1/0,a[e+3]=-1/0,s[e]=1/0,s[e+3]=-1/0;w(o,n,s)}t.sort(B);let f=s;for(let e=0;e<f;e++){const n=t[e];for(;e+1<f&&t[e+1].candidate===n.candidate;)t.splice(e+1,1),f--}for(let o=u;o<d;o+=6){const r=n[o+2*e];for(let e=0;e<f;e++){const i=t[e];r>=i.candidate?w(o,n,i.rightCacheBounds):(w(o,n,i.leftCacheBounds),i.count++)}}for(let n=0;n<f;n++){const r=t[n],u=r.count,d=s-r.count,f=r.leftCacheBounds,p=r.rightCacheBounds;let h=0;0!==u&&(h=b(f)/o);let m=0;0!==d&&(m=b(p)/o);const g=1+i*(h*u+m*d);g<a&&(l=e,a=g,c=r.candidate)}}else{for(let e=0;e<P;e++){const t=A[e];t.count=0,t.candidate=r+f+e*f;const n=t.bounds;for(let e=0;e<3;e++)n[e]=1/0,n[e+3]=-1/0}for(let o=u;o<d;o+=6){let t=~~((n[o+2*e]-r)/f);t>=P&&(t=31);const i=A[t];i.count++,w(o,n,i.bounds)}const t=A[31];v(t.bounds,t.rightCacheBounds);for(let e=30;e>=0;e--){const t=A[e],n=A[e+1];x(t.bounds,n.rightCacheBounds,t.rightCacheBounds)}let p=0;for(let n=0;n<31;n++){const t=A[n],r=t.count,u=t.bounds,d=A[n+1].rightCacheBounds;0!==r&&(0===p?v(u,T):x(u,T,T)),p+=r;let f=0,h=0;0!==p&&(f=b(T)/o);const m=s-p;0!==m&&(h=b(d)/o);const g=1+i*(f*p+h*m);g<a&&(l=e,a=g,c=t.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${a} used.`);return{axis:l,pos:c}}(n.boundingData,d,t,r,s,u);if(-1===p.axis)return U(r+s),n.offset=r,n.count=s,n;const E=k(h,I,t,r,s,p);if(E===r||E===r+s)U(r+s),n.offset=r,n.count=s;else{n.splitAxis=p.axis;const o=new M,i=r,a=E-r;n.left=o,m(t,i,a,o.boundingData,F),e(o,i,a,F,f+1);const l=new M,c=E,u=s-a;n.right=l,m(t,c,u,l.boundingData,F),e(l,c,u,F,f+1)}return n}(R,n,r,F),R;function U(e){f&&f(e/_)}}function H(e,t){const n=e.geometry;t.indirect&&(e._indirectBuffer=function(e,t){const n=(e.index?e.index.count:e.attributes.position.count)/3,r=n>65536,o=r?4:2,i=t?new SharedArrayBuffer(n*o):new ArrayBuffer(n*o),s=r?new Uint32Array(i):new Uint16Array(i);for(let a=0,l=s.length;a<l;a++)s[a]=a;return s}(n,t.useSharedArrayBuffer),function(e,t){const n=d(e),r=h(e,t).sort(((e,t)=>e.offset-t.offset)),o=r[r.length-1];o.count=Math.min(n-o.offset,o.count);let i=0;return r.forEach((e=>{let{count:t}=e;return i+=t})),n!==i}(n,t.range)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),e._indirectBuffer||f(n,t);const r=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o=e.attributes.position,i=e.index?e.index.array:null,s=d(e),l=o.normalized;let c;null===t?(c=new Float32Array(6*s*4),n=0,r=s):(c=t,n=n||0,r=r||s);const u=o.array,f=o.offset||0;let p=3;o.isInterleavedBufferAttribute&&(p=o.data.stride);const h=["getX","getY","getZ"];for(let d=n;d<n+r;d++){const e=3*d,t=6*d;let n=e+0,r=e+1,s=e+2;i&&(n=i[n],r=i[r],s=i[s]),l||(n=n*p+f,r=r*p+f,s=s*p+f);for(let i=0;i<3;i++){let e,d,f;l?(e=o[h[i]](n),d=o[h[i]](r),f=o[h[i]](s)):(e=u[n+i],d=u[r+i],f=u[s+i]);let p=e;d<p&&(p=d),f<p&&(p=f);let m=e;d>m&&(m=d),f>m&&(m=f);const g=(m-p)/2,y=2*i;c[t+y+0]=p+g,c[t+y+1]=g+(Math.abs(p)+g)*a}}return c}(n),i=t.indirect?p(n,t.range):h(n,t.range);e._roots=i.map((n=>{const i=Z(e,o,n.offset,n.count,t),s=W(i),a=new r(32*s);return j(0,i,a),a}))}class V{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let n=1/0,r=-1/0;for(let o=0,i=e.length;o<i;o++){const i=e[o][t];n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}setFromPoints(e,t){let n=1/0,r=-1/0;for(let o=0,i=t.length;o<i;o++){const i=t[o],s=e.dot(i);n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}isSeparated(e){return this.min>e.max||e.min>this.max}}V.prototype.setFromBox=function(){const e=new c.Pq0;return function(t,n){const r=n.min,o=n.max;let i=1/0,s=-1/0;for(let a=0;a<=1;a++)for(let n=0;n<=1;n++)for(let l=0;l<=1;l++){e.x=r.x*a+o.x*(1-a),e.y=r.y*n+o.y*(1-n),e.z=r.z*l+o.z*(1-l);const c=t.dot(e);i=Math.min(c,i),s=Math.max(c,s)}this.min=i,this.max=s}}();!function(){const e=new V}();const Y=function(){const e=new c.Pq0,t=new c.Pq0,n=new c.Pq0;return function(r,o,i){const s=r.start,a=e,l=o.start,c=t;n.subVectors(s,l),e.subVectors(r.end,r.start),t.subVectors(o.end,o.start);const u=n.dot(c),d=c.dot(a),f=c.dot(c),p=n.dot(a),h=a.dot(a)*f-d*d;let m,g;m=0!==h?(u*d-p*f)/h:0,g=(u+m*d)/f,i.x=m,i.y=g}}(),O=function(){const e=new c.I9Y,t=new c.Pq0,n=new c.Pq0;return function(r,o,i,s){Y(r,o,e);let a=e.x,l=e.y;if(a>=0&&a<=1&&l>=0&&l<=1)return r.at(a,i),void o.at(l,s);if(a>=0&&a<=1)return l<0?o.at(0,s):o.at(1,s),void r.closestPointToPoint(s,!0,i);if(l>=0&&l<=1)return a<0?r.at(0,i):r.at(1,i),void o.closestPointToPoint(i,!0,s);{let e,c;e=a<0?r.start:r.end,c=l<0?o.start:o.end;const u=t,d=n;return r.closestPointToPoint(c,!0,t),o.closestPointToPoint(e,!0,n),u.distanceToSquared(c)<=d.distanceToSquared(e)?(i.copy(u),void s.copy(c)):(i.copy(e),void s.copy(d))}}}(),$=function(){const e=new c.Pq0,t=new c.Pq0,n=new c.Zcv,r=new c.cZY;return function(o,i){const{radius:s,center:a}=o,{a:l,b:c,c:u}=i;r.start=l,r.end=c;if(r.closestPointToPoint(a,!0,e).distanceTo(a)<=s)return!0;r.start=l,r.end=u;if(r.closestPointToPoint(a,!0,e).distanceTo(a)<=s)return!0;r.start=c,r.end=u;if(r.closestPointToPoint(a,!0,e).distanceTo(a)<=s)return!0;const d=i.getPlane(n);if(Math.abs(d.distanceToPoint(a))<=s){const e=d.projectPoint(a,t);if(i.containsPoint(e))return!0}return!1}}();function X(e){return Math.abs(e)<1e-15}class G extends c.lMl{constructor(){super(...arguments),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new c.Pq0)),this.satBounds=new Array(4).fill().map((()=>new V)),this.points=[this.a,this.b,this.c],this.sphere=new c.iyt,this.plane=new c.Zcv,this.needsUpdate=!0}intersectsSphere(e){return $(e,this)}update(){const e=this.a,t=this.b,n=this.c,r=this.points,o=this.satAxes,i=this.satBounds,s=o[0],a=i[0];this.getNormal(s),a.setFromPoints(s,r);const l=o[1],c=i[1];l.subVectors(e,t),c.setFromPoints(l,r);const u=o[2],d=i[2];u.subVectors(t,n),d.setFromPoints(u,r);const f=o[3],p=i[3];f.subVectors(n,e),p.setFromPoints(f,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,e),this.needsUpdate=!1}}G.prototype.closestPointToSegment=function(){const e=new c.Pq0,t=new c.Pq0,n=new c.cZY;return function(r){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const{start:s,end:a}=r,l=this.points;let c,u=1/0;for(let d=0;d<3;d++){const s=(d+1)%3;n.start.copy(l[d]),n.end.copy(l[s]),O(n,r,e,t),c=e.distanceToSquared(t),c<u&&(u=c,o&&o.copy(e),i&&i.copy(t))}return this.closestPointToPoint(s,e),c=s.distanceToSquared(e),c<u&&(u=c,o&&o.copy(e),i&&i.copy(s)),this.closestPointToPoint(a,e),c=a.distanceToSquared(e),c<u&&(u=c,o&&o.copy(e),i&&i.copy(a)),Math.sqrt(u)}}(),G.prototype.intersectsTriangle=function(){const e=new G,t=new Array(3),n=new Array(3),r=new V,o=new V,i=new c.Pq0,s=new c.Pq0,a=new c.Pq0,l=new c.Pq0,u=new c.Pq0,d=new c.cZY,f=new c.cZY,p=new c.cZY,h=new c.Pq0;function m(e,t,n){const r=e.points;let o=0,i=-1;for(let a=0;a<3;a++){const{start:e,end:l}=d;e.copy(r[a]),l.copy(r[(a+1)%3]),d.delta(s);const c=X(t.distanceToPoint(e));if(X(t.normal.dot(s))&&c){n.copy(d),o=2;break}const u=t.intersectLine(d,h);if(!u&&c&&h.copy(e),(u||c)&&!X(h.distanceTo(l))){if(o<=1){(1===o?n.start:n.end).copy(h),c&&(i=o)}else if(o>=2){(1===i?n.start:n.end).copy(h),o=2;break}if(o++,2===o&&-1===i)break}}return o}return function(s){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,d=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(e.copy(s),e.update(),s=e);const h=this.plane,g=s.plane;if(Math.abs(h.normal.dot(g.normal))>1-1e-10){const e=this.satBounds,a=this.satAxes;n[0]=s.a,n[1]=s.b,n[2]=s.c;for(let t=0;t<4;t++){const o=e[t],i=a[t];if(r.setFromPoints(i,n),o.isSeparated(r))return!1}const l=s.satBounds,u=s.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let n=0;n<4;n++){const e=l[n],o=u[n];if(r.setFromPoints(o,t),e.isSeparated(r))return!1}for(let s=0;s<4;s++){const e=a[s];for(let s=0;s<4;s++){const a=u[s];if(i.crossVectors(e,a),r.setFromPoints(i,t),o.setFromPoints(i,n),r.isSeparated(o))return!1}}return c&&(d||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),c.start.set(0,0,0),c.end.set(0,0,0)),!0}{const e=m(this,g,f);if(1===e&&s.containsPoint(f.end))return c&&(c.start.copy(f.end),c.end.copy(f.end)),!0;if(2!==e)return!1;const t=m(s,h,p);if(1===t&&this.containsPoint(p.end))return c&&(c.start.copy(p.end),c.end.copy(p.end)),!0;if(2!==t)return!1;if(f.delta(a),p.delta(l),a.dot(l)<0){let e=p.start;p.start=p.end,p.end=e}const n=f.start.dot(a),r=f.end.dot(a),o=p.start.dot(a),i=p.end.dot(a);return(n===i||o===r||r<o!==n<i)&&(c&&(u.subVectors(f.start,p.start),u.dot(a)>0?c.start.copy(f.start):c.start.copy(p.start),u.subVectors(f.end,p.end),u.dot(a)<0?c.end.copy(f.end):c.end.copy(p.end)),!0)}}}(),G.prototype.distanceToPoint=function(){const e=new c.Pq0;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}(),G.prototype.distanceToTriangle=function(){const e=new c.Pq0,t=new c.Pq0,n=["a","b","c"],r=new c.cZY,o=new c.cZY;return function(i){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const l=s||a?r:null;if(this.intersectsTriangle(i,l))return(s||a)&&(s&&l.getCenter(s),a&&l.getCenter(a)),0;let c=1/0;for(let t=0;t<3;t++){let r;const o=n[t],l=i[o];this.closestPointToPoint(l,e),r=l.distanceToSquared(e),r<c&&(c=r,s&&s.copy(e),a&&a.copy(l));const u=this[o];i.closestPointToPoint(u,e),r=u.distanceToSquared(e),r<c&&(c=r,s&&s.copy(u),a&&a.copy(e))}for(let u=0;u<3;u++){const l=n[u],d=n[(u+1)%3];r.set(this[l],this[d]);for(let u=0;u<3;u++){const l=n[u],d=n[(u+1)%3];o.set(i[l],i[d]),O(r,o,e,t);const f=e.distanceToSquared(t);f<c&&(c=f,s&&s.copy(e),a&&a.copy(t))}}return Math.sqrt(c)}}();class K{constructor(e,t,n){this.isOrientedBox=!0,this.min=new c.Pq0,this.max=new c.Pq0,this.matrix=new c.kn4,this.invMatrix=new c.kn4,this.points=new Array(8).fill().map((()=>new c.Pq0)),this.satAxes=new Array(3).fill().map((()=>new c.Pq0)),this.satBounds=new Array(3).fill().map((()=>new V)),this.alignedSatBounds=new Array(3).fill().map((()=>new V)),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),n&&this.matrix.copy(n)}set(e,t,n){this.min.copy(e),this.max.copy(t),this.matrix.copy(n),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}K.prototype.update=function(){const e=this.matrix,t=this.min,n=this.max,r=this.points;for(let l=0;l<=1;l++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=r[1*l|2*o|4*i];s.x=l?n.x:t.x,s.y=o?n.y:t.y,s.z=i?n.z:t.z,s.applyMatrix4(e)}const o=this.satBounds,i=this.satAxes,s=r[0];for(let l=0;l<3;l++){const e=i[l],t=o[l],n=r[1<<l];e.subVectors(s,n),t.setFromPoints(e,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},K.prototype.intersectsBox=function(){const e=new V;return function(t){this.needsUpdate&&this.update();const n=t.min,r=t.max,o=this.satBounds,i=this.satAxes,s=this.alignedSatBounds;if(e.min=n.x,e.max=r.x,s[0].isSeparated(e))return!1;if(e.min=n.y,e.max=r.y,s[1].isSeparated(e))return!1;if(e.min=n.z,e.max=r.z,s[2].isSeparated(e))return!1;for(let a=0;a<3;a++){const n=i[a],r=o[a];if(e.setFromBox(n,t),r.isSeparated(e))return!1}return!0}}(),K.prototype.intersectsTriangle=function(){const e=new G,t=new Array(3),n=new V,r=new V,o=new c.Pq0;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(e.copy(i),e.update(),i=e);const s=this.satBounds,a=this.satAxes;t[0]=i.a,t[1]=i.b,t[2]=i.c;for(let e=0;e<3;e++){const r=s[e],o=a[e];if(n.setFromPoints(o,t),r.isSeparated(n))return!1}const l=i.satBounds,c=i.satAxes,u=this.points;for(let e=0;e<3;e++){const t=l[e],r=c[e];if(n.setFromPoints(r,u),t.isSeparated(n))return!1}for(let e=0;e<3;e++){const i=a[e];for(let e=0;e<4;e++){const s=c[e];if(o.crossVectors(i,s),n.setFromPoints(o,t),r.setFromPoints(o,u),n.isSeparated(r))return!1}}return!0}}(),K.prototype.closestPointToPoint=function(e,t){return this.needsUpdate&&this.update(),t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t},K.prototype.distanceToPoint=function(){const e=new c.Pq0;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}(),K.prototype.distanceToBox=function(){const e=["x","y","z"],t=new Array(12).fill().map((()=>new c.cZY)),n=new Array(12).fill().map((()=>new c.cZY)),r=new c.Pq0,o=new c.Pq0;return function(i){let s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(a||l)&&(i.getCenter(o),this.closestPointToPoint(o,r),i.closestPointToPoint(r,o),a&&a.copy(r),l&&l.copy(o)),0;const c=s*s,u=i.min,d=i.max,f=this.points;let p=1/0;for(let e=0;e<8;e++){const t=f[e];o.copy(t).clamp(u,d);const n=t.distanceToSquared(o);if(n<p&&(p=n,a&&a.copy(t),l&&l.copy(o),n<c))return Math.sqrt(n)}let h=0;for(let r=0;r<3;r++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=(r+1)%3,a=(r+2)%3,l=1<<r|o<<s|i<<a,c=f[o<<s|i<<a],p=f[l];t[h].set(c,p);const m=e[r],g=e[s],y=e[a],v=n[h],x=v.start,w=v.end;x[m]=u[m],x[g]=o?u[g]:d[g],x[y]=i?u[y]:d[g],w[m]=d[m],w[g]=o?u[g]:d[g],w[y]=i?u[y]:d[g],h++}for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)for(let n=0;n<=1;n++){o.x=e?d.x:u.x,o.y=t?d.y:u.y,o.z=n?d.z:u.z,this.closestPointToPoint(o,r);const i=o.distanceToSquared(r);if(i<p&&(p=i,a&&a.copy(r),l&&l.copy(o),i<c))return Math.sqrt(i)}for(let e=0;e<12;e++){const i=t[e];for(let e=0;e<12;e++){const t=n[e];O(i,t,r,o);const s=r.distanceToSquared(o);if(s<p&&(p=s,a&&a.copy(r),l&&l.copy(o),s<c))return Math.sqrt(s)}}return Math.sqrt(p)}}();class Q{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return 0===e.length?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class J extends Q{constructor(){super((()=>new G))}}const ee=new J;const te=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=n=>{t&&e.push(t),t=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==e.length&&this.setBuffer(e.pop())}}};let ne,re;const oe=[],ie=new Q((()=>new c.NRn));function se(e,t,n,r,o,i){ne=ie.getPrimitive(),re=ie.getPrimitive(),oe.push(ne,re),te.setBuffer(e._roots[t]);const s=ae(0,e.geometry,n,r,o,i);te.clearBuffer(),ie.releasePrimitive(ne),ie.releasePrimitive(re),oe.pop(),oe.pop();const a=oe.length;return a>0&&(re=oe[a-1],ne=oe[a-2]),s}function ae(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const{float32Array:a,uint16Array:l,uint32Array:c}=te;let u=2*e;if(I(u,l)){const d=k(e,c),f=_(u,l);return g(e,a,ne),r(d,f,!1,s,i+e,ne)}{const p=F(e),h=q(e,c);let m,y,v,x,w=p,b=h;if(o&&(v=ne,x=re,g(w,a,v),g(b,a,x),m=o(v),y=o(x),y<m)){w=h,b=p;const S=m;m=y,y=S,v=x}v||(v=ne,g(w,a,v));const P=n(v,I(2*w,l),m,s+1,i+w);let B;if(2===P){const R=M(w);B=r(R,E(w)-R,!0,s+1,i+w,v)}else B=P&&ae(w,t,n,r,o,i,s+1);if(B)return!0;x=re,g(b,a,x);const A=n(x,I(2*b,l),y,s+1,i+b);let T;if(2===A){const U=M(b);T=r(U,E(b)-U,!0,s+1,i+b,x)}else T=A&&ae(b,t,n,r,o,i,s+1);return!!T;function M(e){const{uint16Array:t,uint32Array:n}=te;let r=2*e;for(;!I(r,t);)r=2*(e=F(e));return k(e,n)}function E(e){const{uint16Array:t,uint32Array:n}=te;let r=2*e;for(;!I(r,t);)r=2*(e=q(e,n));return k(e,n)+_(r,t)}}}const le=new c.Pq0,ce=new c.Pq0;const ue=new c.Pq0,de=new c.Pq0,fe=new c.Pq0,pe=new c.I9Y,he=new c.I9Y,me=new c.I9Y,ge=new c.Pq0,ye=new c.Pq0,ve=new c.Pq0,xe=new c.Pq0;function we(e,t,n,r,o,i,s,a,l,u,d){ue.fromBufferAttribute(t,i),de.fromBufferAttribute(t,s),fe.fromBufferAttribute(t,a);const f=function(e,t,n,r,o,i,s,a){let l;if(l=i===c.hsX?e.intersectTriangle(r,n,t,!0,o):e.intersectTriangle(t,n,r,i!==c.$EB,o),null===l)return null;const u=e.origin.distanceTo(o);return u<s||u>a?null:{distance:u,point:o.clone()}}(e,ue,de,fe,xe,l,u,d);if(f){r&&(pe.fromBufferAttribute(r,i),he.fromBufferAttribute(r,s),me.fromBufferAttribute(r,a),f.uv=c.lMl.getInterpolation(xe,ue,de,fe,pe,he,me,new c.I9Y)),o&&(pe.fromBufferAttribute(o,i),he.fromBufferAttribute(o,s),me.fromBufferAttribute(o,a),f.uv1=c.lMl.getInterpolation(xe,ue,de,fe,pe,he,me,new c.I9Y)),n&&(ge.fromBufferAttribute(n,i),ye.fromBufferAttribute(n,s),ve.fromBufferAttribute(n,a),f.normal=c.lMl.getInterpolation(xe,ue,de,fe,ge,ye,ve,new c.Pq0),f.normal.dot(e.direction)>0&&f.normal.multiplyScalar(-1));const t={a:i,b:s,c:a,normal:new c.Pq0,materialIndex:0};c.lMl.getNormal(ue,de,fe,t.normal),f.face=t,f.faceIndex=i}return f}function be(e,t,n,r,o,i,s){const a=3*r;let l=a+0,c=a+1,u=a+2;const d=e.index;e.index&&(l=d.getX(l),c=d.getX(c),u=d.getX(u));const{position:f,normal:p,uv:h,uv1:m}=e.attributes,g=we(n,f,p,h,m,l,c,u,t,i,s);return g?(g.faceIndex=r,o&&o.push(g),g):null}function Pe(e,t,n,r){const o=e.a,i=e.b,s=e.c;let a=t,l=t+1,c=t+2;n&&(a=n.getX(a),l=n.getX(l),c=n.getX(c)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),i.x=r.getX(l),i.y=r.getY(l),i.z=r.getZ(l),s.x=r.getX(c),s.y=r.getY(c),s.z=r.getZ(c)}function Be(e,t,n,r,o,i,s){const{geometry:a}=n,{index:l}=a,c=a.attributes.position;for(let u=e,d=t+e;u<d;u++){let e;if(e=u,Pe(s,3*e,l,c),s.needsUpdate=!0,r(s,e,o,i))return!0}return!1}function Ae(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,a,l,c,u=0;const d=e._roots;for(let s=0,p=d.length;s<p;s++)i=d[s],a=new Uint32Array(i),l=new Uint16Array(i),c=new Float32Array(i),f(0,u),u+=i.byteLength;function f(e,n){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const u=2*e;if(l[u+15]===s){const t=a[e+6];let n=1/0,i=1/0,s=1/0,d=-1/0,f=-1/0,p=-1/0;for(let e=3*t,a=3*(t+l[u+14]);e<a;e++){let t=r[e];const a=o.getX(t),l=o.getY(t),c=o.getZ(t);a<n&&(n=a),a>d&&(d=a),l<i&&(i=l),l>f&&(f=l),c<s&&(s=c),c>p&&(p=c)}return(c[e+0]!==n||c[e+1]!==i||c[e+2]!==s||c[e+3]!==d||c[e+4]!==f||c[e+5]!==p)&&(c[e+0]=n,c[e+1]=i,c[e+2]=s,c[e+3]=d,c[e+4]=f,c[e+5]=p,!0)}{const r=e+8,o=a[e+6],s=r+n,l=o+n;let u=i,d=!1,p=!1;t?u||(d=t.has(s),p=t.has(l),u=!d&&!p):(d=!0,p=!0);const h=u||p;let m=!1;(u||d)&&(m=f(r,n,u));let g=!1;h&&(g=f(o,n,u));const y=m||g;if(y)for(let t=0;t<3;t++){const n=r+t,i=o+t,s=c[n],a=c[n+3],l=c[i],u=c[i+3];c[e+t]=s<l?s:l,c[e+t+3]=a>u?a:u}return y}}}function Te(e,t,n,r,o){let i,s,a,l,c,u;const d=1/n.direction.x,f=1/n.direction.y,p=1/n.direction.z,h=n.origin.x,m=n.origin.y,g=n.origin.z;let y=t[e],v=t[e+3],x=t[e+1],w=t[e+3+1],b=t[e+2],P=t[e+3+2];return d>=0?(i=(y-h)*d,s=(v-h)*d):(i=(v-h)*d,s=(y-h)*d),f>=0?(a=(x-m)*f,l=(w-m)*f):(a=(w-m)*f,l=(x-m)*f),!(i>l||a>s)&&((a>i||isNaN(i))&&(i=a),(l<s||isNaN(s))&&(s=l),p>=0?(c=(b-g)*p,u=(P-g)*p):(c=(P-g)*p,u=(b-g)*p),!(i>u||c>s)&&((c>i||i!==i)&&(i=c),(u<s||s!==s)&&(s=u),i<=o&&s>=r))}function Me(e,t,n,r,o,i,s){te.setBuffer(e._roots[t]),Ee(0,e,n,r,o,i,s),te.clearBuffer()}function Ee(e,t,n,r,o,i,s){const{float32Array:a,uint16Array:l,uint32Array:c}=te,u=2*e;if(I(u,l)){!function(e,t,n,r,o,i,s,a){const{geometry:l,_indirectBuffer:c}=e;for(let u=r,d=r+o;u<d;u++)be(l,t,n,u,i,s,a)}(t,n,r,k(e,c),_(u,l),o,i,s)}else{const l=F(e);Te(l,a,r,i,s)&&Ee(l,t,n,r,o,i,s);const u=q(e,c);Te(u,a,r,i,s)&&Ee(u,t,n,r,o,i,s)}}const Se=["x","y","z"];function Ie(e,t,n,r,o,i){te.setBuffer(e._roots[t]);const s=ke(0,e,n,r,o,i);return te.clearBuffer(),s}function ke(e,t,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:l}=te;let c=2*e;if(I(c,a)){return function(e,t,n,r,o,i,s){const{geometry:a,_indirectBuffer:l}=e;let c=1/0,u=null;for(let d=r,f=r+o;d<f;d++){let e;e=be(a,t,n,d,null,i,s),e&&e.distance<c&&(u=e,c=e.distance)}return u}(t,n,r,k(e,l),_(c,a),o,i)}{const a=R(e,l),c=Se[a],u=r.direction[c]>=0;let d,f;u?(d=F(e),f=q(e,l)):(d=q(e,l),f=F(e));const p=Te(d,s,r,o,i)?ke(d,t,n,r,o,i):null;if(p){const e=p.point[c];if(u?e<=s[f+a]:e>=s[f+a+3])return p}const h=Te(f,s,r,o,i)?ke(f,t,n,r,o,i):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const _e=new c.NRn,Fe=new G,qe=new G,Re=new c.kn4,Ue=new K,Ce=new K;function ze(e,t,n,r){te.setBuffer(e._roots[t]);const o=De(0,e,n,r);return te.clearBuffer(),o}function De(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const{float32Array:i,uint16Array:s,uint32Array:a}=te;let l=2*e;null===o&&(n.boundingBox||n.computeBoundingBox(),Ue.set(n.boundingBox.min,n.boundingBox.max,r),o=Ue);if(!I(l,s)){const s=e+8,l=a[e+6];g(s,i,_e);if(o.intersectsBox(_e)&&De(s,t,n,r,o))return!0;g(l,i,_e);return!!(o.intersectsBox(_e)&&De(l,t,n,r,o))}{const o=t.geometry,c=o.index,u=o.attributes.position,d=n.index,f=n.attributes.position,p=k(e,a),h=_(l,s);if(Re.copy(r).invert(),n.boundsTree){g(e,i,Ce),Ce.matrix.copy(Re),Ce.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:e=>Ce.intersectsBox(e),intersectsTriangle:e=>{e.a.applyMatrix4(r),e.b.applyMatrix4(r),e.c.applyMatrix4(r),e.needsUpdate=!0;for(let t=3*p,n=3*(h+p);t<n;t+=3)if(Pe(qe,t,c,u),qe.needsUpdate=!0,e.intersectsTriangle(qe))return!0;return!1}})}for(let e=3*p,t=3*(h+p);e<t;e+=3){Pe(Fe,e,c,u),Fe.a.applyMatrix4(Re),Fe.b.applyMatrix4(Re),Fe.c.applyMatrix4(Re),Fe.needsUpdate=!0;for(let e=0,t=d.count;e<t;e+=3)if(Pe(qe,e,d,f),qe.needsUpdate=!0,Fe.intersectsTriangle(qe))return!0}}}const Ne=new c.kn4,We=new K,je=new K,Le=new c.Pq0,Ze=new c.Pq0,He=new c.Pq0,Ve=new c.Pq0;function Ye(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1/0;t.boundingBox||t.computeBoundingBox(),We.set(t.boundingBox.min,t.boundingBox.max,n),We.needsUpdate=!0;const a=e.geometry,l=a.attributes.position,c=a.index,u=t.attributes.position,f=t.index,p=ee.getPrimitive(),h=ee.getPrimitive();let m=Le,g=Ze,y=null,v=null;o&&(y=He,v=Ve);let x=1/0,w=null,b=null;return Ne.copy(n).invert(),je.matrix.copy(Ne),e.shapecast({boundsTraverseOrder:e=>We.distanceToBox(e),intersectsBounds:(e,t,n)=>n<x&&n<s&&(t&&(je.min.copy(e.min),je.max.copy(e.max),je.needsUpdate=!0),!0),intersectsRange:(e,r)=>{if(t.boundsTree){return t.boundsTree.shapecast({boundsTraverseOrder:e=>je.distanceToBox(e),intersectsBounds:(e,t,n)=>n<x&&n<s,intersectsRange:(t,o)=>{for(let s=t,a=t+o;s<a;s++){Pe(h,3*s,f,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let t=e,n=e+r;t<n;t++){Pe(p,3*t,c,l),p.needsUpdate=!0;const e=p.distanceToTriangle(h,m,y);if(e<x&&(g.copy(m),v&&v.copy(y),x=e,w=t,b=s),e<i)return!0}}}})}for(let o=0,s=d(t);o<s;o++){Pe(h,3*o,f,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let t=e,n=e+r;t<n;t++){Pe(p,3*t,c,l),p.needsUpdate=!0;const e=p.distanceToTriangle(h,m,y);if(e<x&&(g.copy(m),v&&v.copy(y),x=e,w=t,b=o),e<i)return!0}}}}),ee.releasePrimitive(p),ee.releasePrimitive(h),x===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=x,r.faceIndex=w,o&&(o.point?o.point.copy(v):o.point=v.clone(),o.point.applyMatrix4(Ne),g.applyMatrix4(Ne),o.distance=g.sub(o.point).length(),o.faceIndex=b),r)}function Oe(e,t,n,r,o,i,s){const{geometry:a}=n,{index:l}=a,c=a.attributes.position;for(let u=e,d=t+e;u<d;u++){let e;if(e=n.resolveTriangleIndex(u),Pe(s,3*e,l,c),s.needsUpdate=!0,r(s,e,o,i))return!0}return!1}function $e(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t&&Array.isArray(t)&&(t=new Set(t));const n=e.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,a,l,c,u=0;const d=e._roots;for(let s=0,p=d.length;s<p;s++)i=d[s],a=new Uint32Array(i),l=new Uint16Array(i),c=new Float32Array(i),f(0,u),u+=i.byteLength;function f(n,i){let u=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const d=2*n;if(l[d+15]===s){const t=a[n+6];let i=1/0,s=1/0,u=1/0,f=-1/0,p=-1/0,h=-1/0;for(let n=t,a=t+l[d+14];n<a;n++){const t=3*e.resolveTriangleIndex(n);for(let e=0;e<3;e++){let n=t+e;n=r?r[n]:n;const a=o.getX(n),l=o.getY(n),c=o.getZ(n);a<i&&(i=a),a>f&&(f=a),l<s&&(s=l),l>p&&(p=l),c<u&&(u=c),c>h&&(h=c)}}return(c[n+0]!==i||c[n+1]!==s||c[n+2]!==u||c[n+3]!==f||c[n+4]!==p||c[n+5]!==h)&&(c[n+0]=i,c[n+1]=s,c[n+2]=u,c[n+3]=f,c[n+4]=p,c[n+5]=h,!0)}{const e=n+8,r=a[n+6],o=e+i,s=r+i;let l=u,d=!1,p=!1;t?l||(d=t.has(o),p=t.has(s),l=!d&&!p):(d=!0,p=!0);const h=l||p;let m=!1;(l||d)&&(m=f(e,i,l));let g=!1;h&&(g=f(r,i,l));const y=m||g;if(y)for(let t=0;t<3;t++){const o=e+t,i=r+t,s=c[o],a=c[o+3],l=c[i],u=c[i+3];c[n+t]=s<l?s:l,c[n+t+3]=a>u?a:u}return y}}}function Xe(e,t,n,r,o,i,s){te.setBuffer(e._roots[t]),Ge(0,e,n,r,o,i,s),te.clearBuffer()}function Ge(e,t,n,r,o,i,s){const{float32Array:a,uint16Array:l,uint32Array:c}=te,u=2*e;if(I(u,l)){!function(e,t,n,r,o,i,s,a){const{geometry:l,_indirectBuffer:c}=e;for(let u=r,d=r+o;u<d;u++)be(l,t,n,c?c[u]:u,i,s,a)}(t,n,r,k(e,c),_(u,l),o,i,s)}else{const l=F(e);Te(l,a,r,i,s)&&Ge(l,t,n,r,o,i,s);const u=q(e,c);Te(u,a,r,i,s)&&Ge(u,t,n,r,o,i,s)}}const Ke=["x","y","z"];function Qe(e,t,n,r,o,i){te.setBuffer(e._roots[t]);const s=Je(0,e,n,r,o,i);return te.clearBuffer(),s}function Je(e,t,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:l}=te;let c=2*e;if(I(c,a)){return function(e,t,n,r,o,i,s){const{geometry:a,_indirectBuffer:l}=e;let c=1/0,u=null;for(let d=r,f=r+o;d<f;d++){let e;e=be(a,t,n,l?l[d]:d,null,i,s),e&&e.distance<c&&(u=e,c=e.distance)}return u}(t,n,r,k(e,l),_(c,a),o,i)}{const a=R(e,l),c=Ke[a],u=r.direction[c]>=0;let d,f;u?(d=F(e),f=q(e,l)):(d=q(e,l),f=F(e));const p=Te(d,s,r,o,i)?Je(d,t,n,r,o,i):null;if(p){const e=p.point[c];if(u?e<=s[f+a]:e>=s[f+a+3])return p}const h=Te(f,s,r,o,i)?Je(f,t,n,r,o,i):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const et=new c.NRn,tt=new G,nt=new G,rt=new c.kn4,ot=new K,it=new K;function st(e,t,n,r){te.setBuffer(e._roots[t]);const o=at(0,e,n,r);return te.clearBuffer(),o}function at(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const{float32Array:i,uint16Array:s,uint32Array:a}=te;let l=2*e;null===o&&(n.boundingBox||n.computeBoundingBox(),ot.set(n.boundingBox.min,n.boundingBox.max,r),o=ot);if(!I(l,s)){const s=e+8,l=a[e+6];g(s,i,et);if(o.intersectsBox(et)&&at(s,t,n,r,o))return!0;g(l,i,et);return!!(o.intersectsBox(et)&&at(l,t,n,r,o))}{const o=t.geometry,c=o.index,u=o.attributes.position,d=n.index,f=n.attributes.position,p=k(e,a),h=_(l,s);if(rt.copy(r).invert(),n.boundsTree){g(e,i,it),it.matrix.copy(rt),it.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:e=>it.intersectsBox(e),intersectsTriangle:e=>{e.a.applyMatrix4(r),e.b.applyMatrix4(r),e.c.applyMatrix4(r),e.needsUpdate=!0;for(let n=p,r=h+p;n<r;n++)if(Pe(nt,3*t.resolveTriangleIndex(n),c,u),nt.needsUpdate=!0,e.intersectsTriangle(nt))return!0;return!1}})}for(let e=p,n=h+p;e<n;e++){const n=t.resolveTriangleIndex(e);Pe(tt,3*n,c,u),tt.a.applyMatrix4(rt),tt.b.applyMatrix4(rt),tt.c.applyMatrix4(rt),tt.needsUpdate=!0;for(let e=0,t=d.count;e<t;e+=3)if(Pe(nt,e,d,f),nt.needsUpdate=!0,tt.intersectsTriangle(nt))return!0}}}const lt=new c.kn4,ct=new K,ut=new K,dt=new c.Pq0,ft=new c.Pq0,pt=new c.Pq0,ht=new c.Pq0;function mt(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{},i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1/0;t.boundingBox||t.computeBoundingBox(),ct.set(t.boundingBox.min,t.boundingBox.max,n),ct.needsUpdate=!0;const a=e.geometry,l=a.attributes.position,c=a.index,u=t.attributes.position,f=t.index,p=ee.getPrimitive(),h=ee.getPrimitive();let m=dt,g=ft,y=null,v=null;o&&(y=pt,v=ht);let x=1/0,w=null,b=null;return lt.copy(n).invert(),ut.matrix.copy(lt),e.shapecast({boundsTraverseOrder:e=>ct.distanceToBox(e),intersectsBounds:(e,t,n)=>n<x&&n<s&&(t&&(ut.min.copy(e.min),ut.max.copy(e.max),ut.needsUpdate=!0),!0),intersectsRange:(r,o)=>{if(t.boundsTree){const a=t.boundsTree;return a.shapecast({boundsTraverseOrder:e=>ut.distanceToBox(e),intersectsBounds:(e,t,n)=>n<x&&n<s,intersectsRange:(t,s)=>{for(let d=t,P=t+s;d<P;d++){const t=a.resolveTriangleIndex(d);Pe(h,3*t,f,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let n=r,s=r+o;n<s;n++){const t=e.resolveTriangleIndex(n);Pe(p,3*t,c,l),p.needsUpdate=!0;const r=p.distanceToTriangle(h,m,y);if(r<x&&(g.copy(m),v&&v.copy(y),x=r,w=n,b=d),r<i)return!0}}}})}for(let s=0,a=d(t);s<a;s++){Pe(h,3*s,f,u),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let t=r,n=r+o;t<n;t++){const n=e.resolveTriangleIndex(t);Pe(p,3*n,c,l),p.needsUpdate=!0;const r=p.distanceToTriangle(h,m,y);if(r<x&&(g.copy(m),v&&v.copy(y),x=r,w=t,b=s),r<i)return!0}}}}),ee.releasePrimitive(p),ee.releasePrimitive(h),x===1/0?null:(r.point?r.point.copy(g):r.point=g.clone(),r.distance=x,r.faceIndex=w,o&&(o.point?o.point.copy(v):o.point=v.clone(),o.point.applyMatrix4(lt),g.applyMatrix4(lt),o.distance=g.sub(o.point).length(),o.faceIndex=b),r)}const gt=new te.constructor,yt=new te.constructor,vt=new Q((()=>new c.NRn)),xt=new c.NRn,wt=new c.NRn,bt=new c.NRn,Pt=new c.NRn;let Bt=!1;function At(e,t,n,r,o){let i,s,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,c=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,d=arguments.length>9&&void 0!==arguments[9]?arguments[9]:null,f=arguments.length>10&&void 0!==arguments[10]&&arguments[10];f?(i=yt,s=gt):(i=gt,s=yt);const p=i.float32Array,h=i.uint32Array,m=i.uint16Array,y=s.float32Array,v=s.uint32Array,x=s.uint16Array,w=2*t,b=I(2*e,m),P=I(w,x);let B=!1;if(P&&b)B=f?o(k(t,v),_(2*t,x),k(e,h),_(2*e,m),u,l+t,c,a+e):o(k(e,h),_(2*e,m),k(t,v),_(2*t,x),c,a+e,u,l+t);else if(P){const i=vt.getPrimitive();g(t,y,i),i.applyMatrix4(n);const s=F(e),d=q(e,h);g(s,p,xt),g(d,p,wt);const m=i.intersectsBox(xt),v=i.intersectsBox(wt);B=m&&At(t,s,r,n,o,l,a,u,c+1,i,!f)||v&&At(t,d,r,n,o,l,a,u,c+1,i,!f),vt.releasePrimitive(i)}else{const i=F(t),s=q(t,v);g(i,y,bt),g(s,y,Pt);const m=d.intersectsBox(bt),x=d.intersectsBox(Pt);if(m&&x)B=At(e,i,n,r,o,a,l,c,u+1,d,f)||At(e,s,n,r,o,a,l,c,u+1,d,f);else if(m)if(b)B=At(e,i,n,r,o,a,l,c,u+1,d,f);else{const t=vt.getPrimitive();t.copy(bt).applyMatrix4(n);const s=F(e),d=q(e,h);g(s,p,xt),g(d,p,wt);const m=t.intersectsBox(xt),y=t.intersectsBox(wt);B=m&&At(i,s,r,n,o,l,a,u,c+1,t,!f)||y&&At(i,d,r,n,o,l,a,u,c+1,t,!f),vt.releasePrimitive(t)}else if(x)if(b)B=At(e,s,n,r,o,a,l,c,u+1,d,f);else{const t=vt.getPrimitive();t.copy(Pt).applyMatrix4(n);const i=F(e),d=q(e,h);g(i,p,xt),g(d,p,wt);const m=t.intersectsBox(xt),y=t.intersectsBox(wt);B=m&&At(s,i,r,n,o,l,a,u,c+1,t,!f)||y&&At(s,d,r,n,o,l,a,u,c+1,t,!f),vt.releasePrimitive(t)}}return B}const Tt=new K,Mt=new c.NRn,Et={strategy:0,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class St{static serialize(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t={cloneBuffers:!0,...t};const n=e.geometry,r=e._roots,o=e._indirectBuffer,i=n.getIndex();let s;return s=t.cloneBuffers?{roots:r.map((e=>e.slice())),index:i?i.array.slice():null,indirectBuffer:o?o.slice():null}:{roots:r,index:i?i.array:null,indirectBuffer:o},s}static deserialize(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};n={setIndex:!0,indirect:Boolean(e.indirectBuffer),...n};const{index:r,roots:o,indirectBuffer:i}=e,s=new St(t,{...n,[l]:!0});if(s._roots=o,s._indirectBuffer=i||null,n.setIndex){const n=t.getIndex();if(null===n){const n=new c.THS(e.index,1,!1);t.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return s}get indirect(){return!!this._indirectBuffer}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e.index&&e.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if(t=Object.assign({...Et,[l]:!1},t),t.useSharedArrayBuffer&&"undefined"===typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=e,this._roots=null,this._indirectBuffer=null,t[l]||(H(this,t),!e.boundingBox&&t.setBoundingBox&&(e.boundingBox=this.getBoundingBox(new c.NRn))),this.resolveTriangleIndex=t.indirect?e=>this._indirectBuffer[e]:e=>e}refit(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return(this.indirect?$e:Ae)(this,e)}traverse(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this._roots[t],r=new Uint32Array(n),o=new Uint16Array(n);!function t(i){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const l=2*i,c=o[l+15]===s;if(c){const t=r[i+6],s=o[l+14];e(a,c,new Float32Array(n,4*i,6),t,s)}else{const o=i+8,s=r[i+6],l=r[i+7];e(a,c,new Float32Array(n,4*i,6),l)||(t(o,a+1),t(s,a+1))}}(0)}raycast(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.hB5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;const o=this._roots,i=this.geometry,s=[],a=t.isMaterial,l=Array.isArray(t),u=i.groups,d=a?t.side:t,f=this.indirect?Xe:Me;for(let c=0,p=o.length;c<p;c++){const o=l?t[u[c].materialIndex].side:d,i=s.length;if(f(this,c,o,e,s,n,r),l){const e=u[c].materialIndex;for(let t=i,n=s.length;t<n;t++)s[t].face.materialIndex=e}}return s}raycastFirst(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.hB5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;const o=this._roots,i=this.geometry,s=t.isMaterial,a=Array.isArray(t);let l=null;const u=i.groups,d=s?t.side:t,f=this.indirect?Qe:Ie;for(let c=0,p=o.length;c<p;c++){const o=f(this,c,a?t[u[c].materialIndex].side:d,e,n,r);null!=o&&(null==l||o.distance<l.distance)&&(l=o,a&&(o.face.materialIndex=u[c].materialIndex))}return l}intersectsGeometry(e,t){let n=!1;const r=this._roots,o=this.indirect?st:ze;for(let i=0,s=r.length;i<s&&(n=o(this,i,e,t),!n);i++);return n}shapecast(e){const t=ee.getPrimitive(),n=this.indirect?Oe:Be;let{boundsTraverseOrder:r,intersectsBounds:o,intersectsRange:i,intersectsTriangle:s}=e;if(i&&s){const e=i;i=(r,o,i,a,l)=>!!e(r,o,i,a,l)||n(r,o,this,s,i,a,t)}else i||(i=s?(e,r,o,i)=>n(e,r,this,s,o,i,t):(e,t,n)=>n);let a=!1,l=0;const c=this._roots;for(let u=0,d=c.length;u<d;u++){const e=c[u];if(a=se(this,u,o,i,r,l),a)break;l+=e.byteLength}return ee.releasePrimitive(t),a}bvhcast(e,t,n){let{intersectsRanges:r,intersectsTriangles:o}=n;const i=ee.getPrimitive(),s=this.geometry.index,a=this.geometry.attributes.position,l=this.indirect?e=>{const t=this.resolveTriangleIndex(e);Pe(i,3*t,s,a)}:e=>{Pe(i,3*e,s,a)},u=ee.getPrimitive(),d=e.geometry.index,f=e.geometry.attributes.position,p=e.indirect?t=>{const n=e.resolveTriangleIndex(t);Pe(u,3*n,d,f)}:e=>{Pe(u,3*e,d,f)};if(o){const e=(e,n,r,s,a,c,d,f)=>{for(let h=r,m=r+s;h<m;h++){p(h),u.a.applyMatrix4(t),u.b.applyMatrix4(t),u.c.applyMatrix4(t),u.needsUpdate=!0;for(let t=e,r=e+n;t<r;t++)if(l(t),i.needsUpdate=!0,o(i,u,t,h,a,c,d,f))return!0}return!1};if(r){const t=r;r=function(n,r,o,i,s,a,l,c){return!!t(n,r,o,i,s,a,l,c)||e(n,r,o,i,s,a,l,c)}}else r=e}return function(e,t,n,r){if(Bt)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Bt=!0;const o=e._roots,i=t._roots;let s,a=0,l=0;const u=(new c.kn4).copy(n).invert();for(let c=0,d=o.length;c<d;c++){gt.setBuffer(o[c]),l=0;const e=vt.getPrimitive();g(0,gt.float32Array,e),e.applyMatrix4(u);for(let t=0,o=i.length;t<o&&(yt.setBuffer(i[t]),s=At(0,0,n,u,r,a,l,0,0,e),yt.clearBuffer(),l+=i[t].length,!s);t++);if(vt.releasePrimitive(e),gt.clearBuffer(),a+=o[c].length,s)break}return Bt=!1,s}(this,e,t,r)}intersectsBox(e,t){return Tt.set(e.min,e.max,t),Tt.needsUpdate=!0,this.shapecast({intersectsBounds:e=>Tt.intersectsBox(e),intersectsTriangle:e=>Tt.intersectsTriangle(e)})}intersectsSphere(e){return this.shapecast({intersectsBounds:t=>e.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(e)})}closestPointToGeometry(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1/0;return(this.indirect?mt:Ye)(this,e,t,n,r,o,i)}closestPointToPoint(e){return function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1/0;const i=r*r,s=o*o;let a=1/0,l=null;if(e.shapecast({boundsTraverseOrder:e=>(le.copy(t).clamp(e.min,e.max),le.distanceToSquared(t)),intersectsBounds:(e,t,n)=>n<a&&n<s,intersectsTriangle:(e,n)=>{e.closestPointToPoint(t,le);const r=t.distanceToSquared(le);return r<a&&(ce.copy(le),a=r,l=n),r<i}}),a===1/0)return null;const c=Math.sqrt(a);return n.point?n.point.copy(ce):n.point=ce.clone(),n.distance=c,n.faceIndex=l,n}(this,e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0)}getBoundingBox(e){e.makeEmpty();return this._roots.forEach((t=>{g(0,new Float32Array(t),Mt),e.union(Mt)})),e}}const It=c.$Ed||null,kt=(parseInt(c.sPf),new c.RlV),_t=new c.Pq0,Ft=new c.kn4,qt=c.eaF.prototype.raycast,Rt=null!==It?It.prototype.raycast:null,Ut=new c.Pq0,Ct=new c.eaF,zt=[];function Dt(e,t){this.isBatchedMesh?Nt.call(this,e,t):Wt.call(this,e,t)}function Nt(e,t){if(this.boundsTrees){const n=this.boundsTrees,r=this._drawInfo,o=this._drawRanges,i=this.matrixWorld;Ct.material=this.material,Ct.geometry=this.geometry;const s=Ct.geometry.boundsTree,a=Ct.geometry.drawRange;null===Ct.geometry.boundingSphere&&(Ct.geometry.boundingSphere=new c.iyt);for(let l=0,c=r.length;l<c;l++){if(!this.getVisibleAt(l))continue;const s=r[l].geometryIndex;if(Ct.geometry.boundsTree=n[s],this.getMatrixAt(l,Ct.matrixWorld).premultiply(i),!Ct.geometry.boundsTree){this.getBoundingBoxAt(s,Ct.geometry.boundingBox),this.getBoundingSphereAt(s,Ct.geometry.boundingSphere);const e=o[s];Ct.geometry.setDrawRange(e.start,e.count)}Ct.raycast(e,zt);for(let e=0,n=zt.length;e<n;e++){const n=zt[e];n.object=this,n.batchId=l,t.push(n)}zt.length=0}Ct.geometry.boundsTree=s,Ct.geometry.drawRange=a,Ct.material=null,Ct.geometry=null}else Rt.call(this,e,t)}function Wt(e,t){if(this.geometry.boundsTree){if(void 0===this.material)return;Ft.copy(this.matrixWorld).invert(),kt.copy(e.ray).applyMatrix4(Ft),Ut.setFromMatrixScale(this.matrixWorld),_t.copy(kt.direction).multiply(Ut);const n=_t.length(),r=e.near/n,o=e.far/n,i=this.geometry.boundsTree;if(!0===e.firstHitOnly){const n=u(i.raycastFirst(kt,this.material,r,o),this,e);n&&t.push(n)}else{const n=i.raycast(kt,this.material,r,o);for(let r=0,o=n.length;r<o;r++){const o=u(n[r],this,e);o&&t.push(o)}}}else qt.call(this,e,t)}function jt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.boundsTree=new St(this,e),this.boundsTree}function Lt(){this.boundsTree=null}function Zt(e,t){t={strategy:o,verbose:!1,setBoundingBox:!0,maxDepth:40,maxLeafTris:10,indirect:!1,...t},r.useEffect((()=>{if(e.current){e.current.raycast=Dt;const n=e.current.geometry;return n.computeBoundsTree=jt,n.disposeBoundsTree=Lt,n.computeBoundsTree(t),()=>{n.boundsTree&&n.disposeBoundsTree()}}}),[e,JSON.stringify(t)])}},9381:(e,t,n)=>{n.d(t,{M:()=>s});var r=n(7226),o=n(9950),i=n(2880);function s(e){let{all:t,scene:n,camera:s}=e;const a=(0,i.D)((e=>{let{gl:t}=e;return t})),l=(0,i.D)((e=>{let{camera:t}=e;return t})),c=(0,i.D)((e=>{let{scene:t}=e;return t}));return o.useLayoutEffect((()=>{const e=[];t&&(n||c).traverse((t=>{!1===t.visible&&(e.push(t),t.visible=!0)})),a.compile(n||c,s||l);const o=new r.o6l(128);new r.F1T(.01,1e5,o).update(a,n||c),o.dispose(),e.forEach((e=>e.visible=!1))}),[]),null}}}]);